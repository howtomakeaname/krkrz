//# make stub C source for exporting TVPs internal functions.
var copyright =
'/*

	TVP2 ( T Visual Presenter 2 )  A script authoring tool
	Copyright (C) 2000-2009 W.Dee <dee\@kikyou.info> and contributors

	See details of license at "license.txt"
*/
/* This file is always generated by makestub.pl . */
/* Modification by hand will be lost. */
';



///use Compress::Zlib;
///use Digest::MD5  qw(md5 md5_hex md5_base64);


var output_tpstub_h   = "../../../plugins/win32/tp_stub.h";
var output_tpstub_cpp = "../../../plugins/win32/tp_stub.cpp";

//# This TJS script is VERY VERY complicated so I do never want to see again.

var num = 0;
var compression_level = 6; // 0-9: 6=default level

//---------------------------------------------------------------------------
// perl compatible implements...

@if (EMBEDTJS)
System.linkModule("FlexOctet");
System.linkModule("Hash");
function compress(oct) {
	var fxoct = new FlexOctet(oct);
	fxoct.compress(compression_level);
	var r = fxoct.toOctet();
	invalidate fxoct;
	return r;
}
function md5_hex(text) { return Scripts.getMD5HashString(to_octet(text)); }
function savetext(arr, file) { arr.save(path(file)); }
function path(r) { return r; }
@endif
@if (!EMBEDTJS)
Plugins.link("PackinOne.dll");
Plugins.link("BootEncoder.dll");
Storages.setCurrentDirectory(System.exePath);
function compress(oct) { return BootEncoder.compress(oct,compression_level); } 
function md5_hex(text) { return Scripts.getMD5HashString(to_octet(text)); } // for ScriptsEx plugin
function savetext(arr, file) { arr.save2(path(file)); }
function path(r) { return r; }
@endif

var OFH = [];
var OHFH = [];
var OCFH = [];
function die_if(exp, text) { if (exp) throw new Exception(text); }
function load(file, concat="\n") { return [].load(path(file)).join(concat); }
function open(handle, file, isappend) {
	if (isappend) handle.load(path(file));
	else handle.clear();
	&handle.file = file;
}
function print(handle, text) { handle.add(text); }
function close(handle) {
	var text = handle.join("");
	var save = [];
	save.assign(text.split("\n"));
	savetext(save, handle.file);
}
function to_octet(text) {
	var oct = ["<%"];
	if (typeof text == "String") text = [text];
	for (var i=0;i<text.count;++i) {
		var s=text[i];
		switch (typeof s) {
		case "Integer": oct.add("%02x".sprintf(s & 0xFF)); break;
		case "String":
			for (var n=0,len=s.length; n<len; ++n) oct.add("%02x".sprintf(#s.charAt(n) & 0xFF));
			break;
		}
	}
	oct.add("%>");
	var r =oct.join("")!;
	return r;
}
function to_hex(oct, column) {
	var c = 0, r = [];
	for (var n=0,len=oct.length; n<len; ++n) {
		r.add("0x%02x, ".sprintf(oct[n]));
		if (!column) continue;
		c += r[-1].length;
		if (c >= column) {
			c = 0;
			r.add("\n");
		}
	}
	return r.join("");
}
function filter(str, args*) {
	str = (string)str;
	for (var n = 0; n < args.count; n+=2) str = str.replace(args[n], args[n+1]);
	return str;
}
function foreach(arr, cb, *) { for (var n = 0; n < arr.count; ++n) cb(arr[n], *); }
function push(arr, *) { arr.push(*); }
function join(key, arr) { return arr.join(key); }
function makearray(arr*) {
	var r = [];
	for (var n = 0; n < arr.count; ++n) {
		var s = trim(arr[n]);
		if (s != "") r.add(s);
	}
	return r;
}
function trim(str) { return ((string)str).trim(); }
function split(rex, str, *) { return ((string)str).split(rex, *); }
function match(str, rex, *) {
	if (typeof rex == "String") rex = new RegExp(rex, *);
	return rex.match((string)str);
}
function matchall(str, rex, opt="g", cb, *) {
	if (typeof rex == "String") rex = new RegExp(rex, opt);
	str = (string)str;
	do {
		var m = rex.exec(str);
		if (!m || !m.count) break;
		cb(m, *);
	} while (true);
}
function length(str_or_oct) { return str_or_oct.length; }

function _1(m) { return m[1]; }
function _2(m) { return m[2]; }
function _3(m) { return m[3]; }

//---------------------------------------------------------------------------

function normalize_string(str)
{
	var ret, array, array2 = [];
//	$str = $_[0];
	str = filter(trim(str), //  /^\s*(.*?)\s*$/, _1,
				  /[\*][\*]/g, "* *",
				  /[\*][\*]/g, "* *");
	array = split(/\s|\b/, str);
	foreach(array, function (str, array2)
	{
		if (!/\s/.test(str) && str != '')
		{
			push(array2, str);
		}
	}, array2);
	str = join(' ', array2);
	return str;
}

function get_arg_names(args)
{
	var arg, array;
//	$args = $_[0];
	array = split(/,/, args);
	args = [''];
	foreach( array, function (arg, args)
	{
		arg = trim(arg); // filter(arg, /^\s*(.*?)\s*$/, _1);
		var _= match(arg, /^(.*)=(.*)$/);
		if(_.count)
		{
			arg = _[1];
		}
		arg = trim(arg); // filter(arg, /^\s*(.*?)\s*$/, _1);
		_= match(arg, /(\w+)$/);
		args[0] += ', ' if args[0] != '';
		args[0] += _[1];
	}, args);
	return args[0];
}

function except_arg_names(args)
{
	var arg, array;
//	$args = $_[0];
	array = split(/,/, args);
	args = [''];
	foreach( array, function (arg, args)
	{
		arg = trim(arg); // filter(arg, /^\s*(.*?)\s*$/, _1);
		var _=match(arg, /^(.*)=(.*)$/);
		if(_.count)
		{
			arg = _[1];
		}
		arg = trim(arg); // filter(arg, /^\s*(.*?)\s*$/, _1);
		arg = filter(arg, /(.*?)(\w+)$/, _1);
		arg = trim(arg); // filter(arg, /^\s*(.*?)\s*$/, _1);
		args[0] += ',' if args[0] != '';
		args[0] += normalize_string(arg);
	}, args);
	return args[0];
}

function get_ret_type(type, prefix)
{
	var _;
//	$type = $_[0];
//	$prefix = $_[1];

	if(type == @"${prefix}_METHOD_RET_EMPTY")
	{
		return 'void';
	}
	else if((_=match(type, @"${prefix}_METHOD_RET\\((.*?)\\)")) && _.count)
	{
		return normalize_string(_[1]);
	}
	return normalize_string(type);
}

function make_func_stub(
	rettype, // = $_[0];
	name, // = $_[1];
	arg, // = $_[2];
	type, // = $_[3];
	prefix, // = $_[4];
	isconst, // = $_[5];
	isstatic)// = $_[6];
{
//	var rettype, name, arg, type, prefix, isconst, isstatic;
	var _, str, mangled, noreturn, h, argnames, functype, func_exp_name, md5;

	rettype = filter(trim(rettype), /[\n\t]/g, " ");
	name    = filter(trim(name),    /[\n\t]/g, " ");
	arg     = filter(trim(arg),     /[\n\t]/g, " ");

	func_exp_name = 
		((_=match(rettype, @"^${prefix}_METHOD_RET")) && _.count ? '' : normalize_string(rettype)+' ')+
		type+'::'+normalize_string(name)+'('+except_arg_names(arg)+')'+(isconst ? ' const':'');

	var md5 = md5_hex(func_exp_name);

	mangled = @"TVP_Stub_${md5}\t";
	mangled += func_exp_name;
	mangled += "\t"+get_ret_type(rettype, prefix)+
		@"(__stdcall *  __TVP_Stub_${md5})(${type} *_this"+(arg != '' ? ', ' : '')+normalize_string(arg)+")";
	mangled += "\t"+((_=match(rettype, @"^${prefix}_METHOD_RET")) && _.count ? '' : normalize_string(rettype)) +
		" "+normalize_string(type)+"::"+normalize_string(name)+ "("+normalize_string(arg)+")";
	mangled += @"\tTVP_Stub_${md5}";
	mangled += @"\t${md5}";
	mangled += "\t"+get_arg_names(arg);
	functype = (get_ret_type(rettype, prefix)+
				"(__stdcall * __functype)("+(isconst ? "const ": "")+
				(isstatic ? '' : (@"${type} *"+(arg != '' ? ', ' : '')))+
				normalize_string(except_arg_names(arg))+")");
	mangled += "\t"+functype;

	noreturn = 0;
	if(rettype == @"${prefix}_METHOD_RET_EMPTY")
	{
		noreturn = 1;
	}
	else if((_=match(rettype, @"${prefix}_METHOD_RET\((.*?)\)")) && _.count)
	{
		noreturn = 2;
	}

	rettype = get_ret_type(rettype, prefix);

	print(OFH, "static ");
	print(OFH, normalize_string(rettype));
	print(OFH, " __stdcall ");
	print(OFH, @"TVP_Stub_${md5}");
	if(isstatic)
	{
		print(OFH, "(");
	}
	else
	{
		print(OFH, @"(${type} * _this");
		if(arg != '')
		{
			print(OFH, ", ");
		}
	}

	print(OFH, normalize_string(arg));
	print(OFH, ")\n");
	print(OFH, "{\n");
	argnames = get_arg_names(arg);
	if(name == type)
	{
		//# constructor
		print(OFH, @"\t::new (_this) ${name}("+argnames+");\n");
		h =("\t"+normalize_string(name)+"("+normalize_string(arg)+")\n"+
			"\t{\n"+
			@"\t\tif(!TVPImportFuncPtr${md5})\n"+
			"\t\t{\n"+
			@"\t\t\tstatic char funcname[] = \"${func_exp_name}\";\n"+
			@"\t\t\tTVPImportFuncPtr${md5} = TVPGetImportFuncPtr(funcname);\n"+
			"\t\t}\n"+
			@"\t\ttypedef ${functype};\n"+
			@"\t\t((__functype)(TVPImportFuncPtr${md5}))("+(isstatic ? '' : ("this"+(argnames != '' ? ', ' : '')))+argnames+");\n"+
			"\t}\n");
	}
	else if(name == @"~${type}")
	{
		//;# destructor
		print(OFH, @"\t_this->${name}("+argnames+");\n");
		h =("\t"+normalize_string(name)+"("+normalize_string(arg)+")\n"+
			"\t{\n"+
			@"\t\tif(!TVPImportFuncPtr${md5})\n"+
			"\t\t{\n"+
			@"\t\t\tstatic char funcname[] = \"${func_exp_name}\";\n"+
			@"\t\t\tTVPImportFuncPtr${md5} = TVPGetImportFuncPtr(funcname);\n"+
			"\t\t}\n"+
			@"\t\ttypedef ${functype};\n"+
			@"\t\t((__functype)(TVPImportFuncPtr${md5}))("+(isstatic ? '' : ("this"+(argnames != '' ? ', ' : '')))+argnames+");\n"+
			"\t}\n");
	}
	else
	{
		print(OFH, "\t");
		print(OFH, "return ");
		if(isstatic)
		{
			print(OFH, @"${type}::${name}("+argnames+");\n");
		}
		else
		{
			print(OFH, @"_this->${name}("+argnames+");\n");
		}
		h =("\t"+(isstatic ? 'static ' : '')+(noreturn ? '' : rettype+' ') + normalize_string(name)+ "(" + normalize_string(arg) +
			")"+(isconst ? ' const' : '')+"\n"+
			"\t{\n"+
			@"\t\tif(!TVPImportFuncPtr${md5})\n"+
			"\t\t{\n"+
			@"\t\t\tstatic char funcname[] = \"${func_exp_name}\";\n"+
			@"\t\t\tTVPImportFuncPtr${md5} = TVPGetImportFuncPtr(funcname);\n"+
			"\t\t}\n"+
			@"\t\ttypedef ${functype};\n"+
			"\t\t"+((rettype == 'void') ? '' : 'return ')+
			@"((__functype)(TVPImportFuncPtr${md5}))("+(isstatic ? '' : ("this"+(argnames != '' ? ', ' : '')))+argnames+");\n"+
			"\t}\n");
	}
	print(OFH, "}\n");

	push(func_list, mangled);
	push(h_stub, h);
	num++;
}

function list_func_stub(
	prefix, // = $_[0];
	content, // = $_[1];
	type) // = $_[2];
{
//	var prefix, content, type;
	content = filter(trim(content), /[\n]/g, " "); // for "g" option's rex rule

	matchall(content, @"${prefix}_METHOD_DEF\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_, type, prefix)
	{
		make_func_stub(_[1], _[2], _[3], type, prefix, 0, 0);
	}, type, prefix);
	matchall(content, @"${prefix}_CONST_METHOD_DEF\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_, type, prefix)
	{
		make_func_stub(_[1], _[2], _[3], type, prefix, 1, 0);
	}, type, prefix);
	matchall(content, @"${prefix}_STATIC_METHOD_DEF\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_, type, prefix)
	{
		make_func_stub(_[1], _[2], _[3], type, prefix, 0, 1);
	}, type, prefix);
	matchall(content, @"${prefix}_STATIC_CONST_METHOD_DEF\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_, type, prefix)
	{
		make_func_stub(_[1], _[2], _[3], type, prefix, 1, 1);
	}, type, prefix);
}


function make_exp_stub(
	rettype, // = $_[0];
	name, // = $_[1];
	arg) // = $_[2];
{
//	var rettype, name, arg
	var type, prefix, isconst, str, mangled, noreturn, h, argnames;

	rettype = filter(trim(rettype), /[\n\t]/g, " ");
	name    = filter(trim(name),    /[\n\t]/g, " ");
	arg     = filter(trim(arg),     /[\n\t]/g, " ");

	var func_exp_name = normalize_string(rettype)+' '+
		'::'+normalize_string(name)+'('+except_arg_names(arg)+')';

	var md5 = md5_hex(func_exp_name);

	mangled = @"TVP_Stub_${md5}\t"+func_exp_name;
	mangled += "\t"+normalize_string(rettype)+
		" (__stdcall *"+normalize_string(name)+")("+normalize_string(arg)+")";
	mangled += "\t"+normalize_string(rettype) + " "+normalize_string(name)+"("+
		normalize_string(arg)+")";
	mangled += @"\t${name}";
	mangled += @"\t${md5}";
	mangled += "\t"+get_arg_names(arg);
	mangled += "\t"+normalize_string(rettype)+
		" (__stdcall * __functype)("+normalize_string(except_arg_names(arg))+")";
	mangled += "\t"+normalize_string(rettype);

	print(OFH, "static ");
	print(OFH, normalize_string(rettype));
	print(OFH, " __stdcall ");
	print(OFH, @"TVP_Stub_${md5}(");
	print(OFH, normalize_string(arg));
	print(OFH, ")\n");
	print(OFH, "{\n");
	argnames = get_arg_names(arg);
	print(OFH, "\t");
	print(OFH, "return ");
	print(OFH, @"${name}("+argnames+");\n");
	print(OFH, "}\n");

	push(func_list, mangled);
	num++;
}

function process_exp_stub(
	file) // = $_[0];
{
//	var file;

//	open FH, $file or die;
	content = load(file);

	matchall(content, "\\/\\*\\[\\*\\/(.*?)\\/\\*\\]\\*\\/", "g", function (_)
	{
		defs += _[1]+"\n";
	});

	matchall(content, "\\/\\*\\[C\\*\\/(.*?)\\/\\*\\C]\\*\\/", "g", function (_)
	{
		impls += _[1]+"\n";
	});

	matchall(content, "TJS_EXP_FUNC_DEF\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_)
	{
		make_exp_stub(_[1], _[2], _[3]);
	});

	matchall(content, "TVP_GL_FUNC_PTR_EXTERN_DECL\\(\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*\\((.*?)\\)\\s*\\)", "g", function (_)
	{
		make_exp_stub(_[1], _[2], _[3]);
	});

}

//undef($/);
var func_list = [];

open(OFH, "FuncStubs.~h"); // or die;

print(OFH, copyright);

print(OFH, //<<EOF;
'
extern void TVPExportFunctions();
');

close(OFH);
open(OFH, "FuncStubs.~cpp"); // or die;

print(OFH, copyright);

print(OFH, //<<EOF;
'

#include "tjsCommHead.h"

#include "tjsVariant.h"
#include "tjsString.h"
#include "PluginImpl.h"

');


//open(FH, "../../tjs2/tjsVariant.h") or die;
var content = load("../../tjs2/tjsVariant.h");
var _=match(content, "\\/\\*start-of-tTJSVariant\\*\\/(.*?)\\/\\*end-of-tTJSVariant\\*\\/");
var h_stub = [];
list_func_stub("TJS", _[1], "tTJSVariant");
var variant = h_stub;

_=match(content, "\\/\\*start-of-tTJSVariantOctet\\*\\/(.*?)\\/\\*end-of-tTJSVariantOctet\\*\\/");
h_stub = [];
list_func_stub("TJS", _[1], "tTJSVariantOctet");
var variantoctet = h_stub;

//open(FH, "../../tjs2/tjsString.h") or die;
content = load("../../tjs2/tjsString.h");
_=match(content, "\\/\\*start-of-tTJSString\\*\\/(.*?)\\/\\*end-of-tTJSString\\*\\/");
h_stub = [];
list_func_stub("TJS", _[1], "tTJSString");
var string_ = h_stub;

//open(FH, "../../tjs2/tjsVariantString.h") or die;
content = load("../../tjs2/tjsVariantString.h");
_=match(content, "\\/\\*start-of-tTJSVariantString\\*\\/(.*?)\\/\\*end-of-tTJSVariantString\\*\\/");
h_stub = [];
list_func_stub("TJS", _[1], "tTJSVariantString");
var variantstring = h_stub;

var defs = '';
var impls = '';

var method_list = func_list;

func_list = [];

print(OFH, "#include \"tjsTypes.h\"\n");
process_exp_stub("../../tjs2/tjsTypes.h");

print(OFH, "#include \"tjsConfig.h\"\n");
process_exp_stub("../../tjs2/tjsConfig.h");

print(OFH, "#include \"tjsVariantString.h\"\n");
process_exp_stub("../../tjs2/tjsVariantString.h");

print(OFH, "#include \"tjsUtils.h\"\n");
process_exp_stub("../../tjs2/tjsUtils.h");

print(OFH, "#include \"tjsString.h\"\n");
process_exp_stub("../../tjs2/tjsString.h");

print(OFH, "#include \"tjsInterface.h\"\n");
process_exp_stub("../../tjs2/tjsInterface.h");

print(OFH, "#include \"tjsErrorDefs.h\"\n");
process_exp_stub("../../tjs2/tjsErrorDefs.h");

print(OFH, "#include \"tjsNative.h\"\n");
process_exp_stub("../../tjs2/tjsNative.h");

print(OFH, "#include \"tjsVariant.h\"\n");
process_exp_stub("../../tjs2/tjsVariant.h");

print(OFH, "#include \"tjsArray.h\"\n");
process_exp_stub("../../tjs2/tjsArray.h");

print(OFH, "#include \"tjsDictionary.h\"\n");
process_exp_stub("../../tjs2/tjsDictionary.h");

print(OFH, "#include \"tjs.h\"\n");
process_exp_stub("../../tjs2/tjs.h");

print(OFH, "#include \"tjsMessage.h\"\n");
process_exp_stub("../../tjs2/tjsMessage.h");

print(OFH, "#include \"tjsGlobalStringMap.h\"\n");
process_exp_stub("../../tjs2/tjsGlobalStringMap.h");

print(OFH, "#include \"tjsObject.h\"\n");
process_exp_stub("../../tjs2/tjsObject.h");
process_exp_stub("../../tjs2/tjsObject.cpp");

var defs_system = defs;
defs = '';

print(OFH, "#include \"StorageIntf.h\"\n");
process_exp_stub("../StorageIntf.h");

print(OFH, "#include \"TextStream.h\"\n");
process_exp_stub("../TextStream.h");

print(OFH, "#include \"CharacterSet.h\"\n");
process_exp_stub("../CharacterSet.h");

print(OFH, "#include \"XP3Archive.h\"\n");
process_exp_stub("../XP3Archive.h");

print(OFH, "#include \"EventIntf.h\"\n");
process_exp_stub("../EventIntf.h");

print(OFH, "#include \"SystemIntf.h\"\n");
process_exp_stub("../SystemIntf.h");

print(OFH, "#include \"SystemImpl.h\"\n");
process_exp_stub("./SystemImpl.h");

print(OFH, "#include \"ScriptMgnIntf.h\"\n");
process_exp_stub("../ScriptMgnIntf.h");

print(OFH, "#include \"StorageImpl.h\"\n");
process_exp_stub("../win32/StorageImpl.h");

print(OFH, "#include \"PluginImpl.h\"\n");
process_exp_stub("../win32/PluginImpl.h");

print(OFH, "#include \"SysInitIntf.h\"\n");
process_exp_stub("../SysInitIntf.h");

print(OFH, "#include \"SysInitImpl.h\"\n");
process_exp_stub("../win32/SysInitImpl.h");

print(OFH, "#include \"DetectCPU.h\"\n");
process_exp_stub("../../environ/win32/DetectCPU.h");

print(OFH, "#include \"ThreadIntf.h\"\n");
process_exp_stub("../../utils/ThreadIntf.h");

print(OFH, "#include \"DebugIntf.h\"\n");
process_exp_stub("../../utils/DebugIntf.h");

//#print(OFH, "#include \"KAGParser.h\"\n");
//#process_exp_stub("../../utils/KAGParser.h");

print(OFH, "#include \"Random.h\"\n");
process_exp_stub("../../utils/Random.h");

print(OFH, "#include \"ClipboardIntf.h\"\n");
process_exp_stub("../../utils/ClipboardIntf.h");

print(OFH, "#include \"TickCount.h\"\n");
process_exp_stub("../../utils/TickCount.h");

print(OFH, "#include \"MsgIntf.h\"\n");
process_exp_stub("../../msg/MsgIntf.h");

print(OFH, "#include \"WaveIntf.h\"\n");
process_exp_stub("../../sound/WaveIntf.h");

print(OFH, "#include \"WaveImpl.h\"\n");
process_exp_stub("../../sound/win32/WaveImpl.h");

//#print(OFH, "#include \"MIDIImpl.h\"\n");
//#process_exp_stub("../../sound/win32/MIDIImpl.h");

print(OFH, "#include \"GraphicsLoaderIntf.h\"\n");
process_exp_stub("../../visual/GraphicsLoaderIntf.h");

print(OFH, "#include \"tvpfontstruc.h\"\n");
process_exp_stub("../../visual/tvpfontstruc.h");

print(OFH, "#include \"tvpinputdefs.h\"\n");
process_exp_stub("../../visual/tvpinputdefs.h");

print(OFH, "#include \"LayerBitmapIntf.h\"\n");
process_exp_stub("../../visual/LayerBitmapIntf.h");

print(OFH, "#include \"drawable.h\"\n");
process_exp_stub("../../visual/drawable.h");

print(OFH, "#include \"ComplexRect.h\"\n");
process_exp_stub("../../visual/ComplexRect.h");

print(OFH, "#include \"LayerIntf.h\"\n");
process_exp_stub("../../visual/LayerIntf.h");

print(OFH, "#include \"LayerManager.h\"\n");
process_exp_stub("../../visual/LayerManager.h");

print(OFH, "#include \"WindowIntf.h\"\n");
process_exp_stub("../../visual/WindowIntf.h");

print(OFH, "#include \"WindowImpl.h\"\n");
process_exp_stub("../../visual/win32/WindowImpl.h");

print(OFH, "#include \"DrawDevice.h\"\n");
process_exp_stub("../../visual/win32/DrawDevice.h");

print(OFH, "#include \"voMode.h\"\n");
process_exp_stub("../../visual/voMode.h");

print(OFH, "#include \"VideoOvlIntf.h\"\n");
process_exp_stub("../../visual/VideoOvlIntf.h");

print(OFH, "#include \"TransIntf.h\"\n");
process_exp_stub("../../visual/TransIntf.h");

print(OFH, "#include \"transhandler.h\"\n");
process_exp_stub("../../visual/transhandler.h");

print(OFH, "#include \"tvpgl.h\"\n");
process_exp_stub("../../visual/tvpgl.h");

print(OFH, "#include \"tvpgl_ia32_intf.h\"\n");
process_exp_stub("../../visual/IA32/tvpgl_ia32_intf.h");

var defs_misc = defs;
defs = '';

var all_list = []; all_list.push(method_list*, func_list*);

print(OFH, //<<EOF;
'
#include <zlib/zlib.h>
');

var func_data = [];
foreach(all_list, function (each)
{
	var pair = split(/\t/, each);
	func_data.push(pair[1], 0);
});
func_data = to_octet(func_data);

var deflateout; // = '';

deflateout = compress(func_data);
//# ($deflate, $status) = deflateInit( -Level => Z_BEST_COMPRESSION );
//# ($deflateout, $status) = $deflate->deflate( $func_data );
//# ($deflateout, $status) = $deflate->flush();

var emitdata = to_hex(deflateout, 96);
//$emitdata = $deflateout;
//$emitdata =~ s/(.)/sprintf("0x%02x, ", ord $1)/seg;
//$emitdata =~ s/(.{96})/$1\n/g;
//$emitdata .= "\n";
//# $emitdata =~ s/(.*?), \n/\t__emit__($1);\n/sg;

print(OFH, //<<EOF;
@'/* function table is pretty large; is compressed via zlib */
static tjs_uint8 compressed_functable[] = {
${emitdata}

};
static void * func_ptrs[] = {
');

var i = 0;
foreach(all_list, function (each)
{
	print(OFH, "\t");
	var pair = split(/\t/, each);
	print(OFH, pair[0]+ ",");
	print(OFH, "\n");
	i ++;
});

print(OFH, //<<EOF;
'
};

');

print(OFH, //<<EOF;
'
void TVPExportFunctions()
{
');


print(OFH, "\tconst unsigned long compressed_size = "+length(deflateout)+";\n");
print(OFH, "\tconst unsigned long decompressed_size = "+length(func_data)+";\n");
print(OFH, "\tconst tjs_int function_count = "+i+";\n");

print(OFH, //<<EOF;
'	unsigned char * dest = new unsigned char [decompressed_size];

	try
	{
		unsigned long dest_size = decompressed_size;

		int result = uncompress(dest, &dest_size,
			(unsigned char*)compressed_functable, compressed_size);
		if(result != Z_OK || dest_size != decompressed_size) { TVPThrowInternalError; }

		const unsigned char *p = dest;

		for(tjs_int i = 0; i < function_count; i++)
		{
			TVPAddExportFunction((const char *)p, ((void **)func_ptrs)[i]);
			while(*p) p++;
			p++;
		}
	}
	catch(...)
	{
		delete [] dest;
		throw;
	}
	delete [] dest;
}');
close(OFH);

//# stub library for plugin

open(OHFH, output_tpstub_h); // or die;
open(OCFH, output_tpstub_cpp); // or die;

print(OHFH, copyright);
print(OCFH, copyright);

var func_count = all_list.count + 1;


print(OCFH, // <<EOF;
'
#include <windows.h>
#include "tp_stub.h"

#define TVP_IN_PLUGIN_STUB

tjs_int TVPPluginGlobalRefCount = 0;

//---------------------------------------------------------------------------
// stubs
//---------------------------------------------------------------------------
');


print(OHFH, // <<EOF;
'#ifndef __TP_STUB_H__
#define __TP_STUB_H__

#ifndef __cplusplus
	#error Sorry, currently tp_stub.h can only be used in C++ mode.
#endif

#ifndef _WIN32
	#error Sorry, currently tp_stub.h can only be used in Win32 VC++ or Borland compilers.
#endif



');

print(OHFH, defs_system);


print(OHFH, // <<EOF;
'
#ifdef __BORLANDC__
#pragma warn -8027
#endif

//---------------------------------------------------------------------------
// function import pointers
//---------------------------------------------------------------------------

extern void * TVPGetImportFuncPtr(const char *name);


');

foreach(all_list, function(each)
{
	var pair = split(/\t/, each);

	print(OHFH, "extern void * TVPImportFuncPtr"+pair[5]+";\n");
});



print(OHFH, // <<EOF;
'

//---------------------------------------------------------------------------
// tTJSVariantString
//---------------------------------------------------------------------------

');

//open(FH, "../../tjs2/tjsVariantString.h") or die;
content = load("../../tjs2/tjsVariantString.h");


print(OHFH, // <<EOF;
'class tTJSVariantString : protected tTJSVariantString_S
{
	// do not create an instance of this class directly.

public:
');

foreach(variantstring, function(each)
{
	print(OHFH, each+"\n");
});
_=match(content, "\\/\\*start-of-tTJSVariantString\\*\\/(.*?)\\/\\*end-of-tTJSVariantString\\*\\/");
var class_ = _[1];
matchall(class_,  "\\/\\*m\\[\\*\\/(.*?)\\/\\*\\]m\\*\\/", "g", function (_)
{
	print(OHFH, "\t");
	print(OHFH, _[1]);
	print(OHFH, "\n\n");
});

print(OHFH, // <<EOF;
'};
');

print(OHFH, // <<EOF;
'//---------------------------------------------------------------------------
// tTJSVariantOctet
//---------------------------------------------------------------------------

');

//open(FH, "../../tjs2/tjsVariant.h") or die;
content = load("../../tjs2/tjsVariant.h");


print(OHFH, // <<EOF;
'class tTJSVariantOctet : protected tTJSVariantOctet_S
{
	// do not create an instance of this class directly.

public:
');

foreach(variantoctet, function (each)
{
	print(OHFH, each+"\n");
});

_=match(content, "\\/\\*start-of-tTJSVariantOctet\\*\\/(.*?)\\/\\*end-of-tTJSVariantOctet\\*\\/");
class_ = _[1];
matchall(class_, "\\/\\*m\\[\\*\\/(.*?)\\/\\*\\]m\\*\\/", "g", function (_)
{
	print(OHFH, "\t");
	print(OHFH, _[1]);
	print(OHFH, "\n\n");
});

print(OHFH, // <<EOF;
'};
');


print(OHFH, // <<EOF;
'//---------------------------------------------------------------------------
// tTJSVariant
//---------------------------------------------------------------------------

');

//open(FH, "../../tjs2/tjsVariant.h") or die;
content = load("../../tjs2/tjsVariant.h");


print(OHFH, // <<EOF;
'class tTJSVariant : protected tTJSVariant_S
{

public:
');

foreach(variant, function (each)
{
	print(OHFH, each+"\n");
});

_=match(content, "\\/\\*start-of-tTJSVariant\\*\\/(.*?)\\/\\*end-of-tTJSVariant\\*\\/");
class_ = _[1];
matchall(class_, "\\/\\*m\\[\\*\\/(.*?)\\/\\*\\]m\\*\\/", "g", function (_)
{
	print(OHFH, "\t");
	print(OHFH, _[1]);
	print(OHFH, "\n\n");
});

print(OHFH, // <<EOF;
'};
');

print(OHFH, // <<EOF;
'//---------------------------------------------------------------------------
// tTJSString
//---------------------------------------------------------------------------

');

//open(FH, "../../tjs2/tjsString.h") or die;
content = load("../../tjs2/tjsString.h");


print(OHFH, // <<EOF;
'class tTJSString : protected tTJSString_S
{

public:
');

foreach(string_, function (each)
{
	print(OHFH, each+"\n");
});

_=match(content, "\\/\\*start-of-tTJSString\\*\\/(.*?)\\/\\*end-of-tTJSString\\*\\/");
class_ = _[1];
matchall(class_, "\/\*m\[\*\/(.*?)\/\*\]m\*\/", "g", function (_)
{
	print(OHFH, "\t");
	print(OHFH, _[1]);
	print(OHFH, "\n\n");
});

print(OHFH, // <<EOF;
'};
');

print(OHFH, // <<EOF;
'
//---------------------------------------------------------------------------
// stubs (misc)
//---------------------------------------------------------------------------

');

print(OHFH, defs_misc);


print(OHFH, // <<EOF;
'//---------------------------------------------------------------------------




//---------------------------------------------------------------------------
// stubs
//---------------------------------------------------------------------------

');


foreach(func_list, function (each)
{
	var pair = split(/\t/, each);
	print(OHFH, "inline "+pair[3]+"\n");
	print(OHFH, "{\n");
	print(OHFH,
			"\tif(!TVPImportFuncPtr"+pair[5]+")\n"+
			"\t{\n"+
			"\t\tstatic char funcname[] = \""+pair[1]+"\";\n"+
			"\t\tTVPImportFuncPtr"+pair[5]+" = TVPGetImportFuncPtr(funcname);\n"+
			"\t}\n");
	print(OHFH, "\ttypedef "+pair[7]+";\n");
	print(OHFH, "\t"+(pair[8] == 'void' ? '' : 'return ')+"((__functype)(TVPImportFuncPtr"+pair[5]+"))");
	print(OHFH, "("+pair[6]+");\n");
	print(OHFH, "}\n");
});


print(OCFH, // <<EOF;
'//---------------------------------------------------------------------------
// Stub library setup
//---------------------------------------------------------------------------

static iTVPFunctionExporter * TVPFunctionExporter = NULL;

void * TVPGetImportFuncPtr(const char *name)
{
	void *ptr;
	if(TVPFunctionExporter->QueryFunctionsByNarrowString(&name, &ptr, 1))
	{
		// succeeded
	}
	else
	{
		// failed
		static const char *funcname = "void ::TVPThrowPluginUnboundFunctionError(const char *)";
		if(!TVPFunctionExporter->QueryFunctionsByNarrowString(&funcname, &ptr, 1))
		{
			*(int*)0 = 0; // causes an error
		}
		typedef void (__stdcall * __functype)(const char *);
		((__functype)(ptr))(name);
	}
	return ptr;
}

/* TVPInitImportStub : stub initialization */
bool TVPInitImportStub(iTVPFunctionExporter * exporter)
{
	// set TVPFunctionExporter
	TVPFunctionExporter = exporter;
	return true;
}

/* TVPUninitImportStub : stub uninitialization */
void TVPUninitImportStub()
{
}



');


foreach(all_list, function (each)
{
	var pair = split(/\t/, each);

	print(OCFH, "void * TVPImportFuncPtr"+pair[5]+" = NULL;\n");
});



print(OCFH, impls);

print(OHFH, //<<EOF;
'
#ifdef __BORLANDC__
#pragma warn .8027
#endif

//---------------------------------------------------------------------------
// Stub library setup
//---------------------------------------------------------------------------
extern bool TVPInitImportStub(iTVPFunctionExporter * exporter);
extern void TVPUninitImportStub();
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Global reference count
//---------------------------------------------------------------------------
extern tjs_int TVPPluginGlobalRefCount;
//---------------------------------------------------------------------------

');

//close(OCFH);
//close(OHFH);



//#---------------------------------------------------------------------------
//# exception protected function stub
//#---------------------------------------------------------------------------

//# currently only for iTJSDispatch2

//# read the header
//open OHFH, "$output_tpstub_h" or die;
//undef $/;
var oh = OHFH.join(""); //load(output_tpstub_h);
//close OHFH;

//# extract iTJSDispatch2 declaration
die_if(!((_=match(oh, "class\\s+iTJSDispatch2\\s+\\{(.*?)\\}")) && _.count), "iTJSDispatch2 class not found");
var class_iTJSDispatch2 = _[1];

//# eliminate comments
class_iTJSDispatch2 = filter(class_iTJSDispatch2, new RegExp("//.*?\\n","g"), "");
class_iTJSDispatch2 = filter(class_iTJSDispatch2, new RegExp("/\\*.*?\\*/","g"), "");

//# extract method declarations
var hc = '';
var cc = '';

cc += (// <<EOF;
'
static bool TJS_USERENTRY _CatchFuncCall(void *data, const tTVPExceptionDesc & desc)
{
	throw desc;
}');

matchall(class_iTJSDispatch2,
	"virtual\\s+(\\w+)\\s+TJS_INTF_METHOD\\s+(\\w+)\\s*\\(\\s*(.*?)\\s*\\)", "g", function (_)
{
	var ret_type = _[1];
	var method_name = _[2];
	var args = split(new RegExp("\\s*,\\s*"), _[3] == 'void' ? '' : _[3]);

	hc += 
		(@"extern ${ret_type} Try_iTJSDispatch2_${method_name}(" +
			join(', ',  makearray("iTJSDispatch2 * _this", args*)) + ");\n");


	cc += @"\nstruct t_iTJSDispatch2_${method_name}\n";
	cc += "{\n";
	if(ret_type != 'void')
	{
		cc += @"\t${ret_type} _ret;\n";
	}

	foreach(makearray("iTJSDispatch2 * _this", args*), function (arg)
	{
		cc += @"\t${arg};\n";
	});

	var arg_names = [];
	foreach(args, function (arg, arg_names)
	{
		var _;
		if((_=match(arg, /(\w+)$/)) && _.count)
		{
			push(arg_names, _[1]);
		}
	}, arg_names);
	cc += @"\tt_iTJSDispatch2_${method_name}(\n\t\t\t";
	cc += join("_,\n\t\t\t",  makearray("iTJSDispatch2 * _this", args*));
	cc += "_\n\t\t\t) :\n\t\t";
	var arg_initials = [];
	foreach(makearray("_this", arg_names*), function (arg_name, arg_initials)
	{
		push(arg_initials, @"${arg_name}(${arg_name}_)");
	}, arg_initials);

	cc += join(",\n\t\t", arg_initials);
	cc += "\t{;}\n";

	cc += "\n};\n";

	cc += @"static void TJS_USERENTRY _Try_iTJSDispatch2_${method_name}(void *data)\n";
	cc += "{\n";
	cc += @"	t_iTJSDispatch2_${method_name} * arg = (t_iTJSDispatch2_${method_name} *)data;\n";
	cc += "	arg->_ret = \n" if ret_type != 'void';
	cc += @"	arg->_this->${method_name}(\n		";
	var arg_args = [];
	foreach(arg_names, function (arg_name, arg_args)
	{
		push(arg_args, @"arg->${arg_name}");
	}, arg_args);
	cc += join(",\n\t\t", arg_args);
	cc += "\n		);\n";
	cc += "}\n";
	cc += 
		(@"${ret_type} Try_iTJSDispatch2_${method_name}(" +
			join(', ', makearray("iTJSDispatch2 * _this", args*)) + ")\n");
	cc += "{\n";
	cc += @"	t_iTJSDispatch2_${method_name} arg(\n		";
	cc += join(",\n		", makearray("_this", arg_names*));
	cc += "\n	);\n";
	cc += @"	TVPDoTryBlock(_Try_iTJSDispatch2_${method_name}, _CatchFuncCall, NULL, \&arg);\n";
	cc += "	return arg._ret;\n" if ret_type != 'void';
	cc += "}";

});


//open(OHFH, output_tpstub_h, true); // or die;
print(OHFH, //<<EOF;
'//---------------------------------------------------------------------------
// exception protected function stub
//---------------------------------------------------------------------------

');
print(OHFH, hc);
print(OHFH, //<<EOF;
'
#endif');
close(OHFH);

//open(OCFH,output_tpstub_cpp, true); // or die;
print(OCFH, // <<EOF;
'//---------------------------------------------------------------------------
// exception protected function stub
//---------------------------------------------------------------------------

');
print(OCFH, cc);
close(OCFH);


//#---------------------------------------------------------------------------


